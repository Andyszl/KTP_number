#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb 14 11:22:49 2019

@author: admin
"""
import cv2
import numpy as np
from operator import itemgetter, attrgetter



def cv_show(name, img):
	cv2.imshow(name, img)
	cv2.waitKey(0)
	cv2.destroyAllWindows()



image1 = cv2.imread("/Users/admin/Desktop/th-3.jpeg",1)
image=cv2.resize(image1,(50*16,500))
gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

#ret, thresh1 = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)#二值处理

# 定义核函数
rectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 15))  # 返回矩形核函数
sqKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 15))
tophat = cv2.morphologyEx(gray, cv2.MORPH_TOPHAT, rectKernel)
gradX = cv2.Sobel(tophat, ddepth=cv2.CV_32F, dx=1, dy=0,  ksize=-1)  # ksize=-1相当于用3*3的
cv2.imshow('gradX',gradX) 
gradX = np.absolute(gradX)
(minVal, maxVal) = (np.min(gradX), np.max(gradX))
gradX = (255 * ((gradX - minVal) / (maxVal - minVal)))
gradX = gradX.astype("uint8")
# print (np.array(gradX).shape)


# 通过闭操作（先膨胀，再腐蚀）将数字连在一起
gradX = cv2.morphologyEx(gradX, cv2.MORPH_CLOSE, rectKernel)
# THRESH_OTSU会自动寻找合适的阈值，适合双峰，需把阈值参数设置为0
thresh = cv2.threshold(gradX, 0, 255,
	cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]


# 再来一个闭操作


thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, sqKernel)  # 再来一个闭操作
thresh_, threshCnts, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)


cnts = threshCnts
cur_img = image.copy()
cv2.drawContours(cur_img,cnts,-1,(0,0,255),3)
copy=image.copy()

locs = []
    # 遍历轮廓
for (i, c) in enumerate(cnts):
    # 计算矩形
    (x, y, w, h) = cv2.boundingRect(c)

    ar = w / float(h)
    # 选择合适的区域，根据实际任务来，这里的基本都是四个数字一组
    #if ar >10:

    #if (w > 40 ) and (h > 10 and h < 20):
            #符合的留下来
    if h > 10 and w > 100 and x<300:
        img = cv2.rectangle(copy,(x,y),(x+w,y+h),(0,255,0),2)
        locs.append((x, y, w, h,w*h))
# 将符合的轮廓按照面积从大到小排序
locs = sorted(locs, key=itemgetter(1), reverse=False)
cv_show('img', img)
print(locs)
print(locs[1][0])
nik=image[locs[1][1]-10:locs[1][1] + locs[1][3]+10, locs[1][0]-10:locs[1][0] + locs[1][2]+10]
cv_show('nik', nik)
#print(nik)
text=image[locs[2][1]-10:locs[2][1] + locs[2][3]+10, locs[2][0]-10:locs[2][0] + locs[2][2]+10]


gray_text = cv2.cvtColor(text, cv2.COLOR_RGB2GRAY)
#gray_text = cv2.GaussianBlur(gray_text, (3, 3), 0)
ret_text, thresh_text = cv2.threshold(gray_text, 127, 255, cv2.THRESH_BINARY)


#NIK_NUMBER模版匹配识别

#从左到右进行排列识别
def sort_contours(cnts, method="left-to-right"):
    reverse = False
    i = 0

    if method == "right-to-left" or method == "bottom-to-top":
        reverse = True

    if method == "top-to-bottom" or method == "bottom-to-top":
        i = 1
    boundingBoxes = [cv2.boundingRect(c) for c in cnts] #用一个最小的矩形，把找到的形状包起来x,y,h,w
    (cnts, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),
                                key=lambda b: b[1][i], reverse=reverse))
    return cnts, boundingBoxes



# 读取一个模板图像
img = cv2.imread("/Users/admin/Desktop/模型数据/img_sfz/match.png")
cv_show('img', img)
# 灰度图
ref = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv_show('ref', ref)
# 二值图像
ref = cv2.threshold(ref, 66, 255, cv2.THRESH_BINARY_INV)[1]
cv_show('ref', ref)

# 计算轮廓
# cv2.findContours()函数接受的参数为二值图，即黑白的（不是灰度图）,cv2.RETR_EXTERNAL只检测外轮廓，cv2.CHAIN_APPROX_SIMPLE只保留终点坐标
# 返回的list中每个元素都是图像中的一个轮廓

ref_, refCnts, hierarchy = cv2.findContours(ref.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

cv2.drawContours(img, refCnts, -1, (0, 0, 255), 3)
cv_show('img', img)
print(np.array(refCnts).shape)
refCnts = sort_contours(refCnts, method="left-to-right")[0]  # 排序，从左到右，从上到下
digits = {}

# 遍历每一个轮廓
for (i, c) in enumerate(refCnts):
	# 计算外接矩形并且resize成合适大小
	(x, y, w, h) = cv2.boundingRect(c)
    #if 
	roi = ref[y:y + h, x:x + w]
	roi = cv2.resize(roi, (57, 88))

	# 每一个数字对应每一个模板
	digits[i] = roi
	#cv_show('digits[i]', digits[i])


#nik = np.clip(nik, 0, 255)    
#nik = np.array(nik,np.uint8)
#NIK识别
gray_nik = cv2.cvtColor(nik, cv2.COLOR_BGR2GRAY)
#gray_nik = cv2.GaussianBlur(gray_nik, (3, 3), 0)
#ret_nik, thresh_nik = cv2.threshold(gray_nik, 127, 255, cv2.THRESH_BINARY)
cv_show('gray_nik',gray_nik)

group = cv2.threshold(gray_nik, 127, 255, cv2.THRESH_BINARY_INV)[1]
cv_show('group',group)
# 计算每一组的轮廓
group_, digitCnts, hierarchy_nik = cv2.findContours(group.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

nik_r=nik.copy()



cv2.drawContours(nik_r, digitCnts, -1, (0, 0, 255), 3)
cv_show('nik_r', nik_r)
print(np.array(digitCnts).shape)

#定位NIK的位置
gX = locs[1][0]
gY = locs[1][1]
gW = locs[1][2]
gH = locs[1][3]


ctx = sort_contours(digitCnts, method="left-to-right")[0]

locs_x = []
    # 遍历轮廓
for (i, c) in enumerate(ctx):
    # 计算矩形
    (x, y, w, h) = cv2.boundingRect(c)

    # 选择合适的区域，根据实际任务来，这里的基本都是四个数字一组

    if h > 10 and w > 10:
        img = cv2.rectangle(nik_r,(x,y),(x+w,y+h),(0,255,0),2)
        locs_x.append((x, y, w, h))


#digitCnts = sort_contours(digitCnts, method="left-to-right")[0]

cv_show('img', img)
print(locs_x)
print(np.array(locs_x).shape)
output = []
groupOutput = []
# 计算每一组中的每一个数值
for c in locs_x:
	# 找到当前数值的轮廓，resize成合适的的大小
	(x, y, w, h) = c
	roi = group[y:y + h, x:x + w]
	roi = cv2.resize(roi, (57, 88))
	#cv_show('roi',roi)

	# 计算匹配得分
	scores = []
		
	# 在模板中计算每一个得分
	for (digit, digitROI) in digits.items():
		# 模板匹配
		result = cv2.matchTemplate(roi, digitROI,
			cv2.TM_CCOEFF)
		(_, score, _, _) = cv2.minMaxLoc(result)
		scores.append(score)

	# 得到最合适的数字

	groupOutput.append(str(np.argmax(scores)))


# 画出来
cv2.rectangle(image, (gX - 5, gY - 5),
	(gX + gW + 5, gY + gH + 5), (0, 0, 255), 1)
cv2.putText(image, "".join(groupOutput), (gX, gY - 15),
	cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
# 图像，文字内容， 坐标 ，字体，大小，颜色，字体厚度

# 得到结果
output.extend(groupOutput)

# 打印结果
print("Credit Card #: {}".format("".join(output)))
cv2.imshow("Image", image)
cv2.waitKey(0)








#cv2.imshow('gray_nik',gray_nik) 
#cv2.imshow('thresh_nik',thresh_nik) 
#cv2.imshow('gray_text',gray_text)
#cv2.imshow('thresh_text',thresh_text)
#cv2.imshow('gradX',gradX) 
#cv2.imshow('thresh',thresh) 
#cv2.imshow('cur_img',cur_img) 
#cv2.imshow('img',img) 
#cv2.waitKey(0)
#cv2.destroyAllWindows()
